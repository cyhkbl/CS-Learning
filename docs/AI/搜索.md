# 搜索

- 动作(Action): `func Action(State): Return 可执行的动作(Action)列表`
- 转移模型(Transition Model): `func Result(State, Action): Return 在执行动作(Action)之后的新状态(State)`
- 状态空间(State Space): 通过`Action`可达的`State`的集合
- 路径代价(Path Cost): `func PathCost(CurrentCost, State1, Action, State2): Return 新的路径代价(Path Cost)`
- 节点(Node): 包含`State`、`Parent Node`、`Action`、`Path Cost(From initial state)`的数据结构

## 搜索算法

## 深度优先搜索(Depth-First Search, DFS)

我们可以首先定义一个初始节点，探索包含该节点的Frontier（前沿），初始化一个Frontier栈，对于初始节点，Frontier就是该节点；同时，定义一个Explored（已探索）集合，初始为空。然后，我们重复以下步骤:

1. 此时Frontier为空：无解
2. 此时Frontier不为空：从Frontier中出栈一个节点
3. 如果该节点是目标状态：成功，返回解决方案
4. 否则，扩展该节点，生成其子节点，并将不在Explored集合和Frontier中的子节点入栈到Frontier中
5. 将该节点添加到Explored集合中

实际上，DFS是首先深入搜索到一个分支的尽头，然后回溯到最近的分叉点，继续探索其他分支，直到找到目标状态或所有可能的路径都被探索完毕。

## 广度优先搜索(Breadth-First Search, BFS)

我们可以首先定义一个初始节点，探索包含该节点的Frontier（前沿），初始化一个Frontier队列，对于初始节点，Frontier就是该节点；同时，定义一个Explored（已探索）集合，初始为空。然后，我们重复以下步骤:

1. 此时Frontier为空：无解
2. 此时Frontier不为空：从Frontier中出队一个节点
3. 如果该节点是目标状态：成功，返回解决方案
4. 否则，扩展该节点，生成其子节点，并将不在Explored集合和Frontier中的子节点入队到Frontier中
5. 将该节点添加到Explored集合中

实际上，BFS是逐层搜索（搜索的都是和初始节点距离相同的节点），从初始节点开始，首先探索所有直接相连的节点，然后是这些节点的子节点，依此类推，直到找到目标状态或所有可能的路径都被探索完毕。