# 环境配置

虚拟环境（Python virtual environment）就是**给某个项目单独准备的一套“隔离的 Python 运行环境”**：它有自己独立的 `python`、`pip` 和一份只属于这个项目的第三方库安装目录。

这样做的核心好处是：

* **避免依赖冲突**：A 项目需要 `mkdocs-material==9.x`，B 项目可能需要别的版本；虚拟环境让它们互不影响。
* **不污染系统 Python**：不会把一堆库装到全局里，系统更干净。
* **更容易复现**：把依赖写进 `requirements.txt`，别人创建同样的虚拟环境就能跑起来。

---

## 你会在虚拟环境里看到什么变化？

启用虚拟环境后：

* 你运行 `python` / `pip` 指向的是虚拟环境里的版本
* `pip install ...` 安装的包只进这个项目的环境，不会影响别的项目

---

## 最常用的创建/使用方式（内置 venv）

在项目目录下：

```bash
python -m venv .venv
```

启用：

* macOS / Linux:

```bash
source .venv/bin/activate
```

* Windows (PowerShell):

```powershell
.venv\Scripts\Activate.ps1
```

启用后你通常会看到命令行前面出现 `(.venv)`。

退出虚拟环境：

```bash
deactivate
```

---

## 跟 MkDocs Material 的关系

文档里说 “ideally by using a virtual environment”，意思是推荐你在虚拟环境里安装，比如：

```bash
pip install mkdocs-material
```

这样 MkDocs Material 只对该项目生效，版本也更可控。

如果你告诉我你用的是 Windows 还是 macOS，我可以把命令按你的系统给一份“复制就能跑”的最短流程。

## 1) 什么是“项目”？

在 Python 语境里，“项目”通常就是**一份独立的代码/文档/应用**的集合（一个文件夹），里面有：

* 你的源代码（`*.py`）、文档、配置
* 依赖描述（比如 `requirements.txt` / `pyproject.toml`）
* 运行入口（脚本、`mkdocs.yml`、服务启动命令等）

比如你要用 MkDocs 写一套文档：一个文件夹里放 `mkdocs.yml`、`docs/` 目录、主题配置等——这整个文件夹就可以叫一个“项目”。

---

## 2) 虚拟环境安装的库，路径是不是在“当前项目文件夹”里？

**通常是的（如果你把 venv 建在项目里）**，但更准确说法是：

* 库不会装进“系统 Python 的安装目录”（全局 site-packages）
* 而是装进**虚拟环境自己的 site-packages 目录**
* 这个虚拟环境目录 **放在哪取决于你创建时指定的位置**

最常见做法是在项目根目录建个 `.venv/`：

```bash
python -m venv .venv
```

此时安装的库会在类似路径：

* macOS/Linux：`项目/.venv/lib/pythonX.Y/site-packages/`
* Windows：`项目\.venv\Lib\site-packages\`

如果你在别处建虚拟环境（比如统一放 `~/venvs/xxx`），那库也会装到那个虚拟环境目录里，而不是项目文件夹。

如何确认当前 `pip` 装到哪里（在已激活 venv 的情况下）：

```bash
python -c "import site; print(site.getsitepackages())"
```

---

## 3) `venv` 和 Anaconda（conda）有什么区别？

它们都能做“隔离环境”，但定位不一样：

### venv（Python 自带）

* **只管理 Python 包**（主要是 `pip` 装的那些）
* 一般更轻量、简单、和 pip/pyproject 生态配合最好
* 环境里通常还是依赖系统的某些底层库（尤其是科学计算相关的 C/Fortran 库时）

适合：Web、脚本、MkDocs、一般 Python 项目（尤其是纯 Python 依赖）。

### conda（Anaconda/Miniconda）

* 不光能管理 Python 包，还能管理很多**非 Python 的二进制依赖**（如 MKL、CUDA、GDAL、某些系统库）
* 环境管理更“全家桶”，对科学计算/数据/地理信息/深度学习（尤其涉及复杂编译依赖）更省心
* 但也更重；而且 conda 与 pip 混用需要一点规矩（能混，但要注意顺序和冲突）

适合：数据科学、机器学习、需要复杂系统依赖的场景。

---

## 4) 它们是不是同一个“环境”概念？

概念类似：都是“给项目隔离依赖”。

但实现不同：

* `venv`：隔离的是 **Python 的 site-packages + python/pip 入口**
* `conda`：隔离的是 **更完整的一套运行时（含非 Python 依赖）**，并且可以安装不同版本的 Python

---

## 5) 实用建议（针对 MkDocs）

MkDocs Material 这种典型纯 Python 工具，**用 `venv + pip` 最顺手**：

* 轻
* 不容易把 conda 环境搞复杂
* 更贴近官方文档写法

如果你本来就长期在用 conda，也完全可以用 conda 环境来装：

```bash
conda create -n docs python=3.11
conda activate docs
pip install mkdocs-material
```

想要我给你一套“在你的系统上最稳的 MkDocs Material 安装流程”，你告诉我你现在是 **Windows/macOS/Linux**，以及你平时用 **conda 还是系统 Python** 就行。

可以，Windows + Scoop 这套很顺：**用 Scoop 管 Python，再用 `venv` 管项目依赖**（MkDocs Material 这种就很适合）。

## 1) 用 Scoop 安装 Python（建议先确认）

```powershell
scoop install python
```

确认现在用到的是 Scoop 的 python：

```powershell
where python
python --version
where pip
pip --version
```

一般 `where python` 会显示类似 `...\scoop\apps\python\current\python.exe`。

---

## 2) 在你的“项目文件夹”里创建虚拟环境

例如你有一个文档项目目录 `D:\docs\my-site`：

```powershell
cd D:\docs\my-site
python -m venv .venv
```

然后激活（PowerShell）：

```powershell
.\.venv\Scripts\Activate.ps1
```

如果你第一次在 PowerShell 里激活失败，通常是执行策略限制。你可以（只改当前用户）：

```powershell
Set-ExecutionPolicy -Scope CurrentUser RemoteSigned
```

然后重新执行激活命令。

激活成功后命令行前面一般会出现 `(.venv)`。

---

## 3) 在虚拟环境里安装 MkDocs Material

激活后执行：

```powershell
python -m pip install -U pip
pip install mkdocs-material
```

验证：

```powershell
mkdocs --version
```

---

## 4) 路径到底在哪里？（你关心的点）

你创建的是 `./.venv`，所以依赖会装到类似：

* `D:\docs\my-site\.venv\Lib\site-packages\`

你可以用命令直接打印出来（在激活状态下）：

```powershell
python -c "import site; print(site.getsitepackages())"
```

也可以确认现在 `python/pip` 指向的是不是虚拟环境：

```powershell
where python
where pip
```

应该优先显示 `...\my-site\.venv\Scripts\...`

---

## 5) Scoop / venv / conda 怎么配合最舒服？

* **Scoop**：管“工具安装”（Python、Git、Node、Pandoc…）——偏系统层面
* **venv**：管“某个项目的 Python 依赖”——偏项目层面
* **conda**：更像“连底层二进制库也一起管”的大环境（数据科学常用）

你想走 Scoop 的路线，最推荐的就是：**Scoop 管 Python + 每个项目一个 `.venv`** ✅

---

如果你愿意，我可以给你一份“从 0 到 `mkdocs serve` 预览”的完整最短流程（含初始化 `mkdocs new`、Material 的 `mkdocs.yml` 最小配置）。

本质上一样：它们都是“激活同一个虚拟环境”，区别只是 **你用的 shell 不同 / 文件名大小写不同 / 调用方式不同**。

## 1) 先搞清楚：`activate` / `Activate.ps1` 都在同一个目录

Windows 下 `venv` 会生成这些脚本（在 `.venv\Scripts\`）：

* `activate`（给 **cmd.exe** 用的入口）
* `activate.bat`（也是给 **cmd.exe**）
* `Activate.ps1`（给 **PowerShell**）
* `activate.fish`（给 fish shell）
* （以及给 Git Bash/MSYS2 的 `activate` 变体，视环境而定）

所以文档写的 `.venv\Scripts\activate` 往往是**简写/概括**，或者它默认你在用 **cmd** / **Git Bash** 这类能直接执行 `activate` 的环境。

## 2) 你写的这两种“方法”是否等价？

你前面用的是 PowerShell：

```powershell
.\.venv\Scripts\Activate.ps1
```

而文档里写的（常见两种理解）：

* 如果你是在 **cmd.exe**：

  ```bat
  .venv\Scripts\activate
  ```

  ✅能用

* 如果你在 **PowerShell**，照抄这句通常会：

  * 要么找不到（因为 `activate` 不是 ps1）
  * 要么不能执行（策略/扩展名原因）

在 PowerShell 里更标准的是：

```powershell
.\.venv\Scripts\Activate.ps1
```

所以：**目的相同（激活 venv），但在 PowerShell 下不一定都能直接用同一条命令。**

## 3) “大小写”有影响吗？

Windows 文件系统一般不区分大小写，所以 `activate` / `Activate` 在路径解析上通常不敏感；但**真正关键是扩展名和 shell 类型**：

* PowerShell 需要 `.ps1`
* cmd 用 `.bat`/无扩展入口都可以

## 4) 你用 Scoop 时，推荐怎么记最稳？

你说你用 Windows + Scoop，平时大概率用 PowerShell（Windows Terminal 也经常默认 PowerShell），那就记这一条最稳：

```powershell
.\.venv\Scripts\Activate.ps1
```

如果你偶尔用 cmd，就用：

```bat
.venv\Scripts\activate
```

想一句话判断“我到底激活成功没”，直接跑：

```powershell
python -c "import sys; print(sys.prefix)"
```

看到输出指向你的 `.venv` 目录就对了。
