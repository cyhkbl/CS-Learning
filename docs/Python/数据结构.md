# 数据结构

## 列表

- 元素个数： `len(<list>)`
- 测试元素是否在列表中： `<element> in <list>`
- 列表推导：`[expression for item in iterable if condition]` 
- 元素求和： `sum(<list>[, start])`  其中不指定 start 则默认为 0，可以指定 start 为空list，则可以结合列表
- 最大值： `max(<list>[, key=function])`，其中 key 参数可以指定一个函数，把函数作用到每个元素上再比较大小
- 加入元素： `<list>.append(<element>)` 在列表末尾添加元素

## 字符串

- 转义字符： `\n` 换行， `\t` 制表符， `\\` 反斜杠， `\'` 单引号， `\"` 双引号

## 字典

- 形式：`{key1: value1, key2: value2}`
- 获取值：`<dict>[key]`
- 显示所有键： `list(<dict>)`，返回一个list
- 显示所有值： `<dict>.values()`，返回`dict_values`对象，可以转换为list
- 键的类型只能是不可变类型，如字符串、数字、元组等，不能是列表、字典等可变类型
- 使用表达式创建字典： `{<key_expression>: <value_expression> for <item> in <iterable> if <condition>}`

## 元组

- 形式：`(<element1>, <element2>, ...)`
- 获取元素：`<tuple>[index]`
- 元组不可变，不能修改、添加或删除元素
- 单元素元组：`(<element>,)` 注意逗号

## 数据抽象

抽象数据类型（ADT）的核心思想：把“数据怎么存”和“数据怎么用”分开。使用数据的程序里应当分离两部分：

1. 数据如何表示/存储：内部结构是什么（用列表、元组、字典、类……）、字段怎么放。
2. 数据如何被操作/使用：外部提供哪些操作（加法、比较、打印等），使用者只调用这些操作。

需要保证：**构造器函数**和**选择器函数**能一起正常工作，从而实现正确的行为。

例如，用分子 `n` 和分母 `d` 构造出一个有理数 `x`，那么再用选择器取出它的分子 `numer(x)` 和分母 `denom(x)` 时，应当满足：

numer(x)/denom(x)=n/d

也就是：**“构造出来的东西”再被“取出来”后，表示的数值要和原来的 n/d 相同**。