# 面向对象

## 类 (Class)

定义了特定类型的对象如何行为的**模板或蓝图**

对象包含数据和行为。`class` 关键字用于定义类，类是对象的一种形式。所有值都是一种对象。

代码实现：

```python
class ClassName:
    def __init__(self, 参数):
        # 初始化属性
        self.属性 = 参数
    def 方法(self, 参数):
        # 方法实现
    attr = 1  # 创建类的属性
```

## 对象 (Object)

类的**实例 (Instance)**；类是该对象的类型。创建实例可以使用类名加括号的形式：`obj = ClassName(参数)`，这会调用类的 `__init__` 方法来初始化对象。

## 方法

> 方法可以看作是在对象上调用的**函数**

调用：对象.方法(参数)

调用时，Python 会将对象本身作为第一个参数传递给方法，通常命名为 `self`。

调用方法时，首先查找实例属性，如果在实例中没找到，系统会转而去该对象所属的类 (Class) 中寻找 <name>。如果类中有这个属性，则返回类属性的值。即实例属性会覆盖类属性。

`getattr(<obj>, <name>[, <default>])`：获取对象 `<obj>` 的属性 `<name>` 的值。如果属性不存在且提供了 `<default>`，则返回 `<default>`，否则引发 `AttributeError`。

对象.方法实际上是一个方法（当不加括号时，被评估为bound method）。可以把它赋值给另一个变量，然后通过该变量调用。而类.方法则是一个函数，需要传入实例对象作为第一个参数。

## 继承

类可以从另一个类继承属性和方法。子类继承父类的所有属性和方法，可以重写父类的方法以提供特定实现。满足is-a关系的类之间可以使用继承。例如：

```python
class Parent:
    def method(self):
        # 父类的方法
class Child(Parent):
    def method(self):
        # 重写父类的方法
```

## 组合

通过在一个类中包含另一个类的实例来实现代码复用和功能扩展。满足has-a关系的类之间可以使用组合。例如：

```python
class Engine:
    def start(self):
        print("Engine started")

class Car:
    def __init__(self):
        self.engine = Engine()

    def start(self):
        self.engine.start()
        print("Car started")

my_car = Car()
my_car.start()
```

## 更改

对于预先声明的可变对象，把它绑定到几个变量上，通过更改其属性或调用其方法来更改对象，不管更改是通过哪个变量进行的，所有变量都会反映出更改后的对象。

## 等同

- Identity（身份）：<exp0> is <exp1>，如果两个变量引用同一个对象，则返回 True，否则返回 False。
- Equality（等值）：<exp0> == <exp1>，如果两个变量引用的对象内容相同，则返回 True，否则返回 False。

对于赋值语句 `<var> = <exp>`，变量 `<var>` 可以代表 `<exp>` 计算结果的对象。

需要注意，等值不代表是同一个对象，例如 [10] is [10] 返回 False。

## 迭代器

迭代器是一个对象，它实现了迭代协议，即包含 `iter()` 和 `next()` 方法。迭代器用于遍历容器（如列表、元组、字典等）中的元素。例如：

```python
t = iter([1, 2, 3])
print(next(t))  # 输出: 1
print(next(t))  # 输出: 2
print(next(t))  # 输出: 3
```

如果在for循环中使用迭代器，Python会自动调用`iter()`和`next()`方法来遍历元素。但是这也会改变迭代器的状态，导致无法重复使用。

`map(<func>, <iterable>)`函数：返回一个迭代器对象，通过对传入的函数依次作用于序列的每个元素，生成新的元素。例如：`map(str, [1, 2, 3])` 会返回一个迭代器，生成字符串 '1', '2', '3'。

`reversed(<iterable>)`函数：返回一个反向迭代的迭代器对象。例如：`reversed([1, 2, 3])` 会返回一个迭代器，生成元素 3, 2, 1。

`filter(<func>, <iterable>)`函数：返回一个迭代器对象，通过对传入的函数依次作用于序列的每个元素，筛选出满足条件的元素。例如：`filter(lambda x: x > 1, [1, 2, 3])` 会返回一个迭代器，生成元素 2, 3。

`zip(<iterable1>, <iterable2>, ...)`函数返回一个聚合了多个可迭代对象的迭代器对象。例如：`zip([1, 2, 3], ['a', 'b', 'c'])` 会返回一个迭代器，生成元组 (1, 'a'), (2, 'b'), (3, 'c')。

for 循环的“自动驾驶”模式

对于for循环：

1. 获取迭代器：它首先调用生成器的 __iter__() 方法（生成器会返回它自己）。
2. 自动迭代：它会自动反复调用 next() 来获取下一个值。
3. 自动停止：当生成器运行结束（抛出 StopIteration 异常）时，for 循环会自动捕捉到这个信号并优雅地停止，而不会报错。

## 生成器

生成器是一种特殊类型的迭代器，通过使用 `yield` 语句定义。生成器函数在调用时不会立即执行，而是返回一个生成器对象，只有在迭代时才会执行函数体，并在每次遇到 `yield` 时暂停并返回一个值。例如：

```python
def count_up_to(n):
    count = 1
    while count <= n:
        yield count
        count += 1
counter = count_up_to(3)
print(next(counter))  # 输出: 1
print(next(counter))  # 输出: 2
print(next(counter))  # 输出: 3
```

`yield from <iterable>` 语句：用于在生成器函数中委托子生成器或可迭代对象。