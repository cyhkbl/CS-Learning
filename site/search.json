{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Blank's CS Learning","text":"<p>My personal notes on computer science topics. Powered by Zensical.</p>","path":["Blank's CS Learning"],"tags":[]},{"location":"Python/Lecture%202/","level":1,"title":"Lecture 2: Functions","text":"<p>对于变量，修改赋值语句中其他变量的值，变量赋值后值始终不变；对于函数，修改其他变量的值，调用函数后函数的返回值可能会受到影响。</p> <p>有重名时，先检查本地帧，再检查全局帧。例如：</p> <pre><code>def square(square):\n    return square * square\nx=square(3)  # 返回 9，这里把3传给了局部变量square，再调用square()函数\n</code></pre> <p>当一个内置函数名称与变量名称冲突时，优先使用变量。例如：</p> <pre><code>def max(x, y):\n    if x &gt; y:\n        return x\n    return y\n\nmax = 42\nprint(max(1, 2))  # 输出 42\n</code></pre> <p>内置函数也可以作为另一个内置函数的变量名。例如：<code>max=min</code>，调用max(1,2)时会调用min函数。</p> <p>python在赋值时，从右往左先查询值，再赋值。</p> <p>解释器不会将 None 作为表达式的值显示出来。当函数不返回任何东西时，默认返回 None。对于<code>print()</code>函数，输出需要打印在屏幕上的字符后，返回 None。例如：</p> <pre><code>&gt;&gt;&gt; print(print(1),print(2))\n1\n2\nNone None\n</code></pre> <p>print 将显示不带引号的文本，但是 return 将保留引号。</p> <p>Traceback 中，最近一次调用位于底部。</p>","path":["Python","Lecture 2: Functions"],"tags":[]},{"location":"Python/Lecture%202/#doctest","level":2,"title":"doctest","text":"<p>doctest 可以快速为你的代码编写测试。</p> <pre><code>def square(x):\n    \"\"\"\n    &gt;&gt;&gt; square(2)\n    4\n    &gt;&gt;&gt; square(3)\n    9\n    \"\"\"\n    return x * x\n</code></pre> <p>要运行doctest，输入：<code>python3 -m doctest file.py</code></p> <p>命令行工具有一个 -v 选项，代表详细（verbose）。</p> <p><code>python3 -m doctest file.py -v</code> 除了告诉您哪些文档测试失败之外，还会告诉您哪些文档测试通过了。</p>","path":["Python","Lecture 2: Functions"],"tags":[]},{"location":"Python/Lecture%202/#_1","level":2,"title":"交互式调试","text":"<p>通过交互方式使用 Python：<code>python3 -i file.py</code></p>","path":["Python","Lecture 2: Functions"],"tags":[]},{"location":"Python/Lecture%202/#print-return","level":2,"title":"print与 return 输出时的区别","text":"<p>在输出字符串时，print() 输出内容，不带引号。 交互式环境自动显示表达式结果，用单引号包裹字符串。</p>","path":["Python","Lecture 2: Functions"],"tags":[]},{"location":"Python/Lecture%203/","level":1,"title":"Lecture 3: Control","text":"<p>程序中，存在全局框架和局部框架。按照缩进区分框架，从而在不同框架中可以使用相同的变量名。</p> <p>return语句可以返回多个值。例如：</p> <pre><code>&gt;&gt;&gt; def divide_exact(n, d):\n...    return n // d, n % d\n&gt;&gt;&gt; quotient, remainder = divide_exact(2013, 10)\n</code></pre>","path":["Python","Lecture 3: Control"],"tags":[]},{"location":"Python/Lecture%203/#python","level":1,"title":"Python中的真假值","text":"<p>False values in Python: False，0，''，None</p> <p>True values in Python: Anything else</p>","path":["Python","Lecture 3: Control"],"tags":[]},{"location":"Python/Lecture%204/","level":1,"title":"Lecture 4: Higher-Order Functions","text":"<p>高阶函数：接受另一个函数作为参数的函数</p>","path":["Python","Lecture 4: Higher-Order Functions"],"tags":[]},{"location":"Python/Lecture%204/#_1","level":2,"title":"函数作为形参和返回值","text":"","path":["Python","Lecture 4: Higher-Order Functions"],"tags":[]},{"location":"Python/Lecture%204/#_2","level":3,"title":"形参","text":"<p>在具有多个形参的函数A中，某些形参可能是函数B。在调用函数A时，一定会自动执行函数B。例如：</p> <pre><code>def if_(c, t, f):\n    if c:\n        return t\n    else:\n        return f\n\nfrom math import sqrt\n\ndef real_sqrt(x):\n    \"\"\"Return the real part of the square root of x.\"\"\"\n    return if_(x &gt;= 0, sqrt(x), 0)\n</code></pre> <p>在执行<code>return if_(x &gt;= 0, sqrt(x), 0)</code>时，函数<code>if_</code>会被调用，并且参数<code>t</code>会被求值为<code>sqrt(x)</code>。这意味着如果<code>x</code>是负数，<code>sqrt(x)</code>仍然会被计算，从而导致报错。</p>","path":["Python","Lecture 4: Higher-Order Functions"],"tags":[]},{"location":"Python/Lecture%204/#_3","level":3,"title":"返回值","text":"<pre><code>def make_adder(n):\n    \"\"\"Return a function that takes one argument k and returns k + n.\"\"\"\n    def adder(k):\n        return k + n\n    return adder\n</code></pre> <p>想计算4+3，可以调用makeadder(3)(4)</p>","path":["Python","Lecture 4: Higher-Order Functions"],"tags":[]},{"location":"Python/Lecture%204/#_4","level":2,"title":"有先后顺序的布尔运算","text":"<p>and和or运算符具有短路特性，即它们会根据第一个操作数的值决定是否计算第二个操作数。使用and时，如果第一个操作数为False，则整个表达式为False，第二个操作数不会被计算。使用or时，如果第一个操作数为True，则整个表达式为True，第二个操作数不会被计算。</p>","path":["Python","Lecture 4: Higher-Order Functions"],"tags":[]},{"location":"Python/Lecture%204/#_5","level":2,"title":"断言语句","text":"<p>断言语句用于在程序中插入检查点，以确保某个条件为真。如果条件为假，程序会抛出一个AssertionError异常。例如：</p> <pre><code>assert 2 &gt; 3, \"This is wrong!\"  # 抛出异常 AssertionError: This is wrong!\n</code></pre>","path":["Python","Lecture 4: Higher-Order Functions"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","level":1,"title":"环境配置","text":"<p>虚拟环境（Python virtual environment）就是给某个项目单独准备的一套“隔离的 Python 运行环境”：它有自己独立的 <code>python</code>、<code>pip</code> 和一份只属于这个项目的第三方库安装目录。</p> <p>这样做的核心好处是：</p> <ul> <li>避免依赖冲突：A 项目需要 <code>mkdocs-material==9.x</code>，B 项目可能需要别的版本；虚拟环境让它们互不影响。</li> <li>不污染系统 Python：不会把一堆库装到全局里，系统更干净。</li> <li>更容易复现：把依赖写进 <code>requirements.txt</code>，别人创建同样的虚拟环境就能跑起来。</li> </ul>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#_2","level":2,"title":"你会在虚拟环境里看到什么变化？","text":"<p>启用虚拟环境后：</p> <ul> <li>你运行 <code>python</code> / <code>pip</code> 指向的是虚拟环境里的版本</li> <li><code>pip install ...</code> 安装的包只进这个项目的环境，不会影响别的项目</li> </ul>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#venv","level":2,"title":"最常用的创建/使用方式（内置 venv）","text":"<p>在项目目录下：</p> <pre><code>python -m venv .venv\n</code></pre> <p>启用：</p> <ul> <li>macOS / Linux:</li> </ul> <pre><code>source .venv/bin/activate\n</code></pre> <ul> <li>Windows (PowerShell):</li> </ul> <pre><code>.venv\\Scripts\\Activate.ps1\n</code></pre> <p>启用后你通常会看到命令行前面出现 <code>(.venv)</code>。</p> <p>退出虚拟环境：</p> <pre><code>deactivate\n</code></pre>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#mkdocs-material","level":2,"title":"跟 MkDocs Material 的关系","text":"<p>文档里说 “ideally by using a virtual environment”，意思是推荐你在虚拟环境里安装，比如：</p> <pre><code>pip install mkdocs-material\n</code></pre> <p>这样 MkDocs Material 只对该项目生效，版本也更可控。</p> <p>如果你告诉我你用的是 Windows 还是 macOS，我可以把命令按你的系统给一份“复制就能跑”的最短流程。</p>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#1","level":2,"title":"1) 什么是“项目”？","text":"<p>在 Python 语境里，“项目”通常就是一份独立的代码/文档/应用的集合（一个文件夹），里面有：</p> <ul> <li>你的源代码（<code>*.py</code>）、文档、配置</li> <li>依赖描述（比如 <code>requirements.txt</code> / <code>pyproject.toml</code>）</li> <li>运行入口（脚本、<code>mkdocs.yml</code>、服务启动命令等）</li> </ul> <p>比如你要用 MkDocs 写一套文档：一个文件夹里放 <code>mkdocs.yml</code>、<code>docs/</code> 目录、主题配置等——这整个文件夹就可以叫一个“项目”。</p>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#2","level":2,"title":"2) 虚拟环境安装的库，路径是不是在“当前项目文件夹”里？","text":"<p>通常是的（如果你把 venv 建在项目里），但更准确说法是：</p> <ul> <li>库不会装进“系统 Python 的安装目录”（全局 site-packages）</li> <li>而是装进虚拟环境自己的 site-packages 目录</li> <li>这个虚拟环境目录 放在哪取决于你创建时指定的位置</li> </ul> <p>最常见做法是在项目根目录建个 <code>.venv/</code>：</p> <pre><code>python -m venv .venv\n</code></pre> <p>此时安装的库会在类似路径：</p> <ul> <li>macOS/Linux：<code>项目/.venv/lib/pythonX.Y/site-packages/</code></li> <li>Windows：<code>项目\\.venv\\Lib\\site-packages\\</code></li> </ul> <p>如果你在别处建虚拟环境（比如统一放 <code>~/venvs/xxx</code>），那库也会装到那个虚拟环境目录里，而不是项目文件夹。</p> <p>如何确认当前 <code>pip</code> 装到哪里（在已激活 venv 的情况下）：</p> <pre><code>python -c \"import site; print(site.getsitepackages())\"\n</code></pre>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#3-venv-anacondaconda","level":2,"title":"3) <code>venv</code> 和 Anaconda（conda）有什么区别？","text":"<p>它们都能做“隔离环境”，但定位不一样：</p>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#venvpython","level":3,"title":"venv（Python 自带）","text":"<ul> <li>只管理 Python 包（主要是 <code>pip</code> 装的那些）</li> <li>一般更轻量、简单、和 pip/pyproject 生态配合最好</li> <li>环境里通常还是依赖系统的某些底层库（尤其是科学计算相关的 C/Fortran 库时）</li> </ul> <p>适合：Web、脚本、MkDocs、一般 Python 项目（尤其是纯 Python 依赖）。</p>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#condaanacondaminiconda","level":3,"title":"conda（Anaconda/Miniconda）","text":"<ul> <li>不光能管理 Python 包，还能管理很多非 Python 的二进制依赖（如 MKL、CUDA、GDAL、某些系统库）</li> <li>环境管理更“全家桶”，对科学计算/数据/地理信息/深度学习（尤其涉及复杂编译依赖）更省心</li> <li>但也更重；而且 conda 与 pip 混用需要一点规矩（能混，但要注意顺序和冲突）</li> </ul> <p>适合：数据科学、机器学习、需要复杂系统依赖的场景。</p>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#4","level":2,"title":"4) 它们是不是同一个“环境”概念？","text":"<p>概念类似：都是“给项目隔离依赖”。</p> <p>但实现不同：</p> <ul> <li><code>venv</code>：隔离的是 Python 的 site-packages + python/pip 入口</li> <li><code>conda</code>：隔离的是 更完整的一套运行时（含非 Python 依赖），并且可以安装不同版本的 Python</li> </ul>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#5-mkdocs","level":2,"title":"5) 实用建议（针对 MkDocs）","text":"<p>MkDocs Material 这种典型纯 Python 工具，用 <code>venv + pip</code> 最顺手：</p> <ul> <li>轻</li> <li>不容易把 conda 环境搞复杂</li> <li>更贴近官方文档写法</li> </ul> <p>如果你本来就长期在用 conda，也完全可以用 conda 环境来装：</p> <pre><code>conda create -n docs python=3.11\nconda activate docs\npip install mkdocs-material\n</code></pre> <p>想要我给你一套“在你的系统上最稳的 MkDocs Material 安装流程”，你告诉我你现在是 Windows/macOS/Linux，以及你平时用 conda 还是系统 Python 就行。</p> <p>可以，Windows + Scoop 这套很顺：用 Scoop 管 Python，再用 <code>venv</code> 管项目依赖（MkDocs Material 这种就很适合）。</p>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#1-scoop-python","level":2,"title":"1) 用 Scoop 安装 Python（建议先确认）","text":"<pre><code>scoop install python\n</code></pre> <p>确认现在用到的是 Scoop 的 python：</p> <pre><code>where python\npython --version\nwhere pip\npip --version\n</code></pre> <p>一般 <code>where python</code> 会显示类似 <code>...\\scoop\\apps\\python\\current\\python.exe</code>。</p>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#2_1","level":2,"title":"2) 在你的“项目文件夹”里创建虚拟环境","text":"<p>例如你有一个文档项目目录 <code>D:\\docs\\my-site</code>：</p> <pre><code>cd D:\\docs\\my-site\npython -m venv .venv\n</code></pre> <p>然后激活（PowerShell）：</p> <pre><code>.\\.venv\\Scripts\\Activate.ps1\n</code></pre> <p>如果你第一次在 PowerShell 里激活失败，通常是执行策略限制。你可以（只改当前用户）：</p> <pre><code>Set-ExecutionPolicy -Scope CurrentUser RemoteSigned\n</code></pre> <p>然后重新执行激活命令。</p> <p>激活成功后命令行前面一般会出现 <code>(.venv)</code>。</p>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#3-mkdocs-material","level":2,"title":"3) 在虚拟环境里安装 MkDocs Material","text":"<p>激活后执行：</p> <pre><code>python -m pip install -U pip\npip install mkdocs-material\n</code></pre> <p>验证：</p> <pre><code>mkdocs --version\n</code></pre>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#4_1","level":2,"title":"4) 路径到底在哪里？（你关心的点）","text":"<p>你创建的是 <code>./.venv</code>，所以依赖会装到类似：</p> <ul> <li><code>D:\\docs\\my-site\\.venv\\Lib\\site-packages\\</code></li> </ul> <p>你可以用命令直接打印出来（在激活状态下）：</p> <pre><code>python -c \"import site; print(site.getsitepackages())\"\n</code></pre> <p>也可以确认现在 <code>python/pip</code> 指向的是不是虚拟环境：</p> <pre><code>where python\nwhere pip\n</code></pre> <p>应该优先显示 <code>...\\my-site\\.venv\\Scripts\\...</code></p>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#5-scoop-venv-conda","level":2,"title":"5) Scoop / venv / conda 怎么配合最舒服？","text":"<ul> <li>Scoop：管“工具安装”（Python、Git、Node、Pandoc…）——偏系统层面</li> <li>venv：管“某个项目的 Python 依赖”——偏项目层面</li> <li>conda：更像“连底层二进制库也一起管”的大环境（数据科学常用）</li> </ul> <p>你想走 Scoop 的路线，最推荐的就是：Scoop 管 Python + 每个项目一个 <code>.venv</code> ✅</p> <p>如果你愿意，我可以给你一份“从 0 到 <code>mkdocs serve</code> 预览”的完整最短流程（含初始化 <code>mkdocs new</code>、Material 的 <code>mkdocs.yml</code> 最小配置）。</p> <p>本质上一样：它们都是“激活同一个虚拟环境”，区别只是 你用的 shell 不同 / 文件名大小写不同 / 调用方式不同。</p>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#1-activate-activateps1","level":2,"title":"1) 先搞清楚：<code>activate</code> / <code>Activate.ps1</code> 都在同一个目录","text":"<p>Windows 下 <code>venv</code> 会生成这些脚本（在 <code>.venv\\Scripts\\</code>）：</p> <ul> <li><code>activate</code>（给 cmd.exe 用的入口）</li> <li><code>activate.bat</code>（也是给 cmd.exe）</li> <li><code>Activate.ps1</code>（给 PowerShell）</li> <li><code>activate.fish</code>（给 fish shell）</li> <li>（以及给 Git Bash/MSYS2 的 <code>activate</code> 变体，视环境而定）</li> </ul> <p>所以文档写的 <code>.venv\\Scripts\\activate</code> 往往是简写/概括，或者它默认你在用 cmd / Git Bash 这类能直接执行 <code>activate</code> 的环境。</p>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#2_2","level":2,"title":"2) 你写的这两种“方法”是否等价？","text":"<p>你前面用的是 PowerShell：</p> <pre><code>.\\.venv\\Scripts\\Activate.ps1\n</code></pre> <p>而文档里写的（常见两种理解）：</p> <ul> <li>如果你是在 cmd.exe：</li> </ul> <pre><code>.venv\\Scripts\\activate\n</code></pre> <p>✅能用</p> <ul> <li> <p>如果你在 PowerShell，照抄这句通常会：</p> </li> <li> <p>要么找不到（因为 <code>activate</code> 不是 ps1）</p> </li> <li>要么不能执行（策略/扩展名原因）</li> </ul> <p>在 PowerShell 里更标准的是：</p> <pre><code>.\\.venv\\Scripts\\Activate.ps1\n</code></pre> <p>所以：目的相同（激活 venv），但在 PowerShell 下不一定都能直接用同一条命令。</p>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#3","level":2,"title":"3) “大小写”有影响吗？","text":"<p>Windows 文件系统一般不区分大小写，所以 <code>activate</code> / <code>Activate</code> 在路径解析上通常不敏感；但真正关键是扩展名和 shell 类型：</p> <ul> <li>PowerShell 需要 <code>.ps1</code></li> <li>cmd 用 <code>.bat</code>/无扩展入口都可以</li> </ul>","path":["环境","环境配置"],"tags":[]},{"location":"%E7%8E%AF%E5%A2%83/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#4-scoop","level":2,"title":"4) 你用 Scoop 时，推荐怎么记最稳？","text":"<p>你说你用 Windows + Scoop，平时大概率用 PowerShell（Windows Terminal 也经常默认 PowerShell），那就记这一条最稳：</p> <pre><code>.\\.venv\\Scripts\\Activate.ps1\n</code></pre> <p>如果你偶尔用 cmd，就用：</p> <pre><code>.venv\\Scripts\\activate\n</code></pre> <p>想一句话判断“我到底激活成功没”，直接跑：</p> <pre><code>python -c \"import sys; print(sys.prefix)\"\n</code></pre> <p>看到输出指向你的 <code>.venv</code> 目录就对了。</p>","path":["环境","环境配置"],"tags":[]}]}